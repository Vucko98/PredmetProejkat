{"version":3,"file":"SparqlXmlParser.js","sourceRoot":"","sources":["SparqlXmlParser.ts"],"names":[],"mappings":"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","sourcesContent":["import {DataFactory} from \"rdf-data-factory\";\nimport * as RDF from \"@rdfjs/types\";\nimport {SaxesParser} from \"saxes\";\nimport {Transform} from \"readable-stream\";\n\n/**\n * Parser for the SPARQL Query Results XML format.\n * @see https://www.w3.org/TR/rdf-sparql-XMLres/\n */\nexport class SparqlXmlParser {\n\n  private readonly dataFactory: RDF.DataFactory;\n  private readonly prefixVariableQuestionMark?: boolean;\n\n  constructor(settings?: ISettings) {\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || new DataFactory();\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n  }\n\n  /**\n   * Convert a SPARQL XML bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n  public parseXmlResultsStream(sparqlResponseStream: NodeJS.ReadableStream): NodeJS.ReadableStream {\n    const errorListener = (error: Error) => resultStream.emit('error', error);\n    sparqlResponseStream.on('error', errorListener);\n\n    const parser = new SaxesParser();\n    const stack: string[] = [];\n    let variablesFound = false;\n    let resultsFound = false;\n    const variables: RDF.Variable[] = [];\n    let currentBindings: IBindings = {};\n    let currentBindingName: string = '';\n    let currentBindingType: string = '';\n    let currentBindingAnnotation: string | RDF.NamedNode | undefined;\n    let currentText: string = '';\n    parser.on(\"error\", errorListener);\n    parser.on(\"opentag\", tag => {\n      if(tag.name === \"variable\" && this.stackEquals(stack,['sparql', 'head'])) {\n        variables.push(this.dataFactory.variable(tag.attributes.name));\n      } else if(tag.name === \"results\" && this.stackEquals(stack, ['sparql'])) {\n        resultsFound = true;\n      } else if(tag.name === 'result' && this.stackEquals(stack, ['sparql', 'results'])) {\n        currentBindings = {};\n      } else if(tag.name === 'binding' && this.stackEquals(stack, ['sparql', 'results', 'result'])) {\n        currentBindingName = tag.attributes.name || '';\n        currentBindingType = '';\n        currentBindingAnnotation = '';\n        currentText = '';\n      } else if(this.stackEquals(stack, ['sparql', 'results', 'result', 'binding'])) {\n        currentBindingType = tag.name;\n        if('xml:lang' in tag.attributes) {\n          currentBindingAnnotation = tag.attributes['xml:lang'];\n        } else if('datatype' in tag.attributes) {\n          currentBindingAnnotation = this.dataFactory.namedNode(tag.attributes.datatype);\n        } else {\n          currentBindingAnnotation = undefined;\n        }\n      }\n      stack.push(tag.name);\n    })\n    parser.on(\"closetag\", tag => {\n      if(this.stackEquals(stack, ['sparql', 'head'])) {\n        resultStream.emit(\"variables\", variables);\n        variablesFound = true;\n      }\n      if(this.stackEquals(stack, ['sparql', 'results', 'result'])) {\n        resultStream.push(currentBindings);\n      }\n      if(this.stackEquals(stack, ['sparql', 'results', 'result', 'binding'])) {\n        const key = this.prefixVariableQuestionMark ? ('?' + currentBindingName) : currentBindingName;\n        if(!currentBindingName && currentBindingType) {\n          errorListener(new Error(`Terms should have a name on line ${parser.line + 1}`));\n        } else if(currentBindingType === 'uri') {\n          currentBindings[key] = this.dataFactory.namedNode(currentText);\n        } else if(currentBindingType === 'bnode') {\n          currentBindings[key] = this.dataFactory.blankNode(currentText);\n        } else if (currentBindingType === 'literal') {\n          currentBindings[key] = this.dataFactory.literal(currentText, currentBindingAnnotation);\n        } else if(currentBindingType) {\n          errorListener(new Error(`Invalid term type '${currentBindingType}' on line ${parser.line + 1}`));\n        }\n      }\n      stack.pop();\n    })\n    parser.on(\"text\", text => {\n      if(this.stackEquals(stack, ['sparql', 'results', 'result', 'binding', currentBindingType])) {\n        currentText = text;\n      }\n    })\n\n    const resultStream = sparqlResponseStream\n        .on(\"end\", _ => {\n          if (!resultsFound) {\n            resultStream.emit(\"error\", new Error(\"No valid SPARQL query results were found.\"))\n          } else if (!variablesFound) {\n            resultStream.emit('variables', []);\n          }\n        })\n        .pipe(new Transform({\n          objectMode: true,\n          transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void) {\n            parser.write(chunk);\n            callback();\n          }\n        }));\n    return resultStream;\n  }\n\n  /**\n   * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.\n   * This will reject if the given response was not a valid boolean response.\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @return {Promise<boolean>} The response boolean.\n   */\n  public parseXmlBooleanStream(sparqlResponseStream: NodeJS.ReadableStream): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const parser = new SaxesParser();\n      const stack: string[] = [];\n      parser.on(\"error\", reject);\n      parser.on(\"opentag\", tag => {\n        stack.push(tag.name);\n      })\n      parser.on(\"closetag\", _ => {\n        stack.pop();\n      })\n      parser.on(\"text\", text => {\n        if(this.stackEquals(stack, ['sparql', 'boolean'])) {\n          resolve(text === 'true');\n        }\n      })\n      sparqlResponseStream\n          .on('error', reject)\n          .on('data', d => parser.write(d))\n          .on('end', () => reject(new Error('No valid ASK response was found.')));\n    });\n  }\n\n  private stackEquals(a: string[], b: string[]) {\n    return a.length === b.length && a.every((v, i) => b[i] === v);\n  }\n}\n\n/**\n * Constructor settings object interface for {@link SparqlXmlParser}.\n */\nexport interface ISettings {\n  /**\n   * A custom datafactory.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * If variable names should be prefixed with a quotation mark.\n   */\n  prefixVariableQuestionMark?: boolean;\n}\n\n/**\n * A bindings object.\n */\nexport interface IBindings {\n  [key: string]: RDF.Term;\n}\n"]}